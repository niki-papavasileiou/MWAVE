from tkinter import Tk, Menu
import tkinter as tk
from tkinter import *
from tkinter.filedialog import askdirectory
import os
import pandas as pd
import matplotlib.ticker as ticker
import tkinter.scrolledtext as st
import cartopy.crs as ccrs
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import sys
import math  
from math import radians, cos, sin, asin, sqrt

def recent_file():

    global index, real_data

    data = []                                           
    real_data = []
    for file in fold_files:

        real_data.append(file)
        data.append(int(file[7:len(file)-4]))               

    i = 0
    for file in fold_files:
        if max(data) == int(file[7:len(file)-4]):
            index = i
        i+=1

    with open(f'{path}/{real_data[index]}', 'r') as f:                                    
        with open("most_recent.txt", "w") as f1:
            for line in f:
                f1.write(line)
    
def open_file():

    global fold_files, path
    path = askdirectory(title = 'select folder')        
    fold_files = os.listdir(path)
    recent_file()

def display(user):

    df = pd.read_csv("most_recent.txt",delim_whitespace=True)
    df['Prec'][df['Prec']<0] = 0

    fig = plt.figure(figsize=(6,6))

    ax=plt.axes(projection=ccrs.PlateCarree())

    lons =df['LON']
    lats =df['LAT']
    z = df[user]

    cs = ax.tricontourf(lons, lats, z,  locator=ticker.MaxNLocator(150),
                        origin='lower',
                        transform = ccrs.PlateCarree(),cmap='jet',extend='both')

    ax.coastlines()
    cbar = plt.colorbar(cs)

    global center_x,center_y, width,angle, height
    center_x = 21.53
    center_y = 39.6
    width = 4
    height = 5
    angle = 1

    center = [center_x,center_y]
    e = patches.Ellipse(xy=center, width=width, height=height, angle = 180+angle,  edgecolor='r', facecolor='none')
    ax.add_patch(e)
    

    filter = df.filter(['LON','LAT'], axis=1)   
    xy = np.array(filter)  

    cosine = np.cos(np.radians(180. - angle))
    sine = np.sin(np.radians(180. - angle)) 
    xc = xy[:,0] - center[0]
    yc = xy[:,1] - center[1]  
    xct = cosine * xc - sine * yc
    yct = sine * xc + cosine * yc  
    rad_cc = (xct**2/(width/2.)**2) + (yct**2/(height/2.)**2)   
    yo = np.array(xy)

    global ellipse_points
    ellipse_points = yo[np.where(rad_cc <= 1.)[0]] 

    global ellipse_df
    ellipse_df = df[df['LON'].isin(ellipse_points[:,0]) & df['LAT'].isin(ellipse_points[:,1])]
    
    global og
    og = sys.stdout

    with open("ellipse_data.txt",'w') as f:
        sys.stdout = f 
        np.set_printoptions(threshold=np.inf)
        print(ellipse_df.to_string())
        sys.stdout = og

    area()
    cities_()
    plt.show(block=False)

def cities_():

    global affected_cities

    cities_df = pd.read_csv("cities.csv", sep = ',')
    d = 3
    def truncate(f, n):
        return math.floor(f * 10 ** n) / 10 ** n
    
    city_lat = cities_df['lat'].astype(float).apply(lambda number: truncate(number, d))
    city_lng = cities_df['lng'].astype(float).apply(lambda number: truncate(number, d))
    
    global cities
    cities = cities_df[city_lng.isin(ellipse_points[:,0]) & city_lat.isin(ellipse_points[:,1])]
    pd.options.mode.chained_assignment = None
    cities['city_info'] = cities['city'] + ', ' + cities['admin_name'] + ', ' + cities['country']
    affected_cities = cities['city_info'].to_string(index=False)

    label_frame_city = LabelFrame(root, text='Affected Cities')
    label_frame_city.pack(expand='yes', fill='both')
    text_city = st.ScrolledText(root, width = 35, height = 8, font = ("calibri",10))
    text_city.place(x=35,y=210)
    text_city.insert(tk.INSERT, str(affected_cities))
    text_city.configure(state ='disabled')

def area():

    lat1_w = radians(center_y)
    lat2_w = radians(center_y+width/2)
    lng1_w = radians(center_x)
    lng2_w = radians(center_x+width/2)
    lat1_h = radians(center_y)
    lat2_h = radians(center_y+height/2)
    lng1_h = radians(center_x)
    lng2_h = radians(center_x+height/2)

    dlat_w = lat2_w - lat1_w
    dlng_w = lng2_w - lng1_w
    a_w = sin(dlat_w / 2)**2 + cos(lat1_w) * cos(lat2_w) * sin(dlng_w / 2)**2
    c_w = 2 * asin(sqrt(a_w)) 
    dlat_h = lat2_h - lat1_h
    dlng_h = lng2_h - lng1_h
    a_h = sin(dlat_h / 2)**2 + cos(lat1_h) * cos(lat2_h) * sin(dlng_h / 2)**2
    c_h = 2 * asin(sqrt(a_h)) 
    r = 6371
    w =c_w * r
    h =c_h * r

    Area = 3.142 * w/2 * h/2 
    area_text = "area: " +str(round(Area, 3)) + "  km^2"

    label_frame_area = LabelFrame(root, text='Info')
    label_frame_area.pack(expand='yes', fill='both')
    text_area = st.ScrolledText(root, width = 20, height = 5, font = ("calibri",10))
    text_area.place(x=35,y=15)
    text_area.insert(tk.INSERT, area_text)
    text_area.configure(state ='disabled')

root = Tk()
root.geometry('520x380')
root.title('gui')
root.resizable(0,0)

menubar = Menu(root)

file = Menu(menubar, tearoff=0)
menubar.add_cascade(label='File', menu=file)
file.add_command(label='Open...', command = open_file)
file.add_separator()
file.add_command(label="Exit", command=root.quit)

help_ = Menu(menubar, tearoff=0)
menubar.add_cascade(label='Help', menu=help_)
help_.add_command(label='About...')

display_ = Menu(menubar, tearoff=0)
menubar.add_cascade(label='Display', menu=display_)
display_.add_command(label='AOD', command = lambda:display('AOD550nm'))
display_.add_command(label='Precipitation', command = lambda:display('Prec'))

root.config(menu=menubar)
root.mainloop()
